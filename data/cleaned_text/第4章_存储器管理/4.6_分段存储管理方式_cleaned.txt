第四章存储器管理 (ExtermalPageTable)。该页表与传统的页表一样，当所访问的页面在内存时，并不需要访 问外部页表，仅当发现所需之页面不在内存时，才使用它。在页表中包含了各个页在外存 的物理位置，通过它可将所需之页面调入内存。 由于在反置页表中是为每一个物理块设置一个页表项，当内存容量很大时，页表项的 数目还是会非常大的。要利用进程标识符和页号去检索这样大的一张线性表是相当费时的。 于是可利用Hash算法来进行检索，这样可以很快地找到在反置页表中的相应页表项。不过 在采用Hash算法时，可能会出现所谓的“地址冲突”，即有多个逻辑地址被映射到同一个 Hash表项上，必须妥善解决这一问题。我们将在文件系统中作进一步的介绍。

4.6分段存储管理方式 存储管理方式随着OS的发展也在不断地发展。当OS由单道向多道发展时，存储管理 存储管理方式又从固定分区分配，发展到动态分区分配。为了能更好地提高内存的利用率， 进而又从连续分配方式发展到离散分配方式一分页存储管理方式。如果说，推动上述发 展的主要动力都是直接或间接地出于提高内存利用率的目的，那么，引入分段存储管理方 式的目的，则主要是为了满足用户（程序员）在编程和使用上多方面的要求，其中有些要求 是其它几种存储管理方式所难以满足的。因此，这种存储管理方式已成为当今所有存储管 理方式的基础，许多高级语言和C语言的编译程序也都支持分段存储管理方式。

4.6.1分段存储管理方式的引入 为什么要引入分段存储管理方式，可从下面两个方面说明：一方面是由于通常的程序 个段大多是一个相对独立的逻辑单位；另一方面，实现和满足信息共享、信息保护、动态 链接以及信息的动态增长等需要，也都是以段为基本单位的。更具体地说，分段存储管理 方式更符合用户和程序员如下多方面的需要。

1.方便编程 通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都从0开始编址，并 有自己的名字和长度。因此，程序员们都迫切地需要访问的逻辑地址是由段名（段号）和段 内偏移量（段内地址)决定的，这不仅可以方使程序员编程，也可使程序非常直观，更具可 读性。例如，下述的两条指令便使用段名和段内地址： LOAD1, [A]1 <D); STORE 1，[B]I(C>; 其中，前一条指令的含义是，将分段A中D单元内的值读入寄存器1；后一条指令的含义 是，将寄存器1的内容存入B分段的C单元中。

2.信息共享 在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，为了共享某个 过程、函数或文件。分页系统中的“页”只是存放信息的物理单位(块)，并无完整的逻辑 145  计算机操作系统 意义，这样，一个可被共享的过程往往可能需要占用数十个页面，这为实现共享增加了困 难。如前所述，段可以是信息的逻辑单位，因此，我们可以为该被共享过程建立一个独立 的段，这就极大地简化了共享的实现。为了实现段的共享，存储管理应能与用户程序分段 的组织方式相适应，有关段共享的具体实现方法将在下一节中介绍。

3.信息保护 信息保护同样是以信息的逻辑单位为基础的，而且经常是以一个过程、函数或文件为 基本单位进行保护的。例如，我们希望函数A仅允许进程执行，而不允许读，更不允许写， 那么，我们只须在包含了函数A的这个段上标上只执行标志即可。但是在分页系统中，函 数A可能要占用若干个页面，而且其中的第一个和最后一个页面还会装有其它程序段的数 据，它们可能有着不同的保护属性，如可以允许进程读写，这样就很难对这些页面实施统 一的保护，因此，分段管理方式能更有效和方便地实现对信息的保护功能。

4.动态增长 在实际应用中，往往存在着一些段，尤其是数据段，在它们的使用过程中，由于数据 量的不断增加，而使数据段动态增长，相应地它所需要的存储空间也会动态增加。然而， 对于数据段究竟会增长到多大，事先又很难确切地知道。对此，很难采取预先多分配的方 法进行解决。前述的其它几种存储管理方式都难以应付这种动态增长的情况，而分段存储 管理方式却能较好地解决这一问题。

5.动态链接 正要运行的目标程序装入内存，也就是说，动态链接在作业运行之前，并不是把所有的目 内存，即启动运行。而在程序运行过程中，当需要调用某个目标程序时，才将该段（目标程 序）调入内存并进行链接。可见，动态链接要求的是以目标程序（即段）作为链接的基本单位， 因此，分段存储管理方式非常适合于动态链接。

4.6.2分段系统的基本原理

1.分段 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑 信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等，如图4-19所示。每 个段都有自已的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因此 各段的长度并不相等。整个作业的地址空间由于被分成多个段，所以呈现出二维特性，亦 即，每个段既包含了一部分地址空间，又标识了逻辑关系。其逻辑地址由段号（段名）和段 内地址所组成。 分段地址中的地址具有如下结构： 段号 段内地址 31 1615 146  第四章存储器管理 在该地址结构中，允许一个作业最长有64K个段，每个段的最大长度为64KB。 分段方式已得到许多编译程序的支持，编译程序能自动地根据源程序的情况产生若干 个段。例如，Pascal编译程序可以为全局变量、用于存储相应参数及返回地址的过程调用 栈、每个过程或函数的代码部分、每个过程或函数的局部变量等，分别建立各自的段。类 似地，Fortran编译程序可以为公共块（Commonblock)建立单独的段，也可以为数组分配一 个单独的段。装入程序将装入所有这些段，并为每个段赋予一个段号。

2.段表 在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而 离散地装入内存中不同的分区中。为保证程序能正常运行，就必须能从物理内存中找出每 个逻辑段所对应的位置。为此，在系统中，类似于分页系统，需为每个进程建立一张段映 射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址（又 称为“基址”）和段的长度，如图4-19所示。段表可以存放在一组寄存器中，以利于提高 地址转换速度。但更常见的方法是将段表放在内存中。在配置了段表后，执行中的进程可 通过查找段表，找到每个段所对应的内存区。可见，段表是用于实现从逻辑段到物理内存 区的映射的。 作业空间 内存空间 (MAIN)=1 段表 40K 段号 段长 基址 30K (MAIN)=0 (X)=1 30K 30K 40K 》 80K 20K 20K 80K (X)=1 (D)=2 30K 15K 120K 120K D(1)=2 10K 150K 15K 15K (S)=3 150K (S)=3 10K 10K 图4-19利用段表实现地址映射

3.地址变换机构 为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于 存放段表始址和段表长度TL。在进行地址变换时，系统将逻辑地址中的段号与段表长度 TL进行比较。若S>TL，表示段号太大，是访问越界，于是产生越界中断信号。若未越界， 则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的 起始地址。然后，再检查段内地址d是否超过该段的段长SL。若超过，即d>SL，同样发 出越界中断信号。若未越界，则将该段的基址d与段内地址相加，即可得到要访问的内存 物理地址。图4-20示出了分段系统的地址变换过程。 147  计算机操作系统 控制寄存器 段号S 位移量W 越界 段表始址段表长度 2 100 有效地址 段号段长 基址 0 1K6K ? 6004K 2 5008K 8192 物理地址 2009200 3 8K 8292 8692 主存 图4-20分段系统的地址变换过程 像分页系统一样，当段表放在内存中时，每要访问一个数据，都须访问两次内存，从 而成倍地降低了计算机的速率。解决的方法和分页系统类似，也增设一个联想存储器，用 于保存最近常用的段表项。一般情况下，由于是段比页大，因而段表项的数目比页表项的 数目少，其所需的联想存储器也相对较小，所以可以显著地减少存取数据的时间，与没有 地址变换的常规存储器相比而言，其存取速度约慢10%～15%。

4.分页和分段的主要区别 由上所述不难看出，分页和分段系统有许多相似之处。比如，两者都采用离散分配方 式，且都是通过地址映射机构实现地址变换。但在概念上两者完全不同，主要表现在下述 三个方面：

（1）页是信息的物理单位。采用分页存储管理方式是为实现离散分配方式，以消减内 存的外零头，提高内存的利用率。或者说，分页仅仅只是系统管理上的需要，完全是系统 的行为，对用户是不可见的。分段存储管理方式中的段则是信息的逻辑单位，它通常包含 的是一组意义相对完整的信息。分段的目的主要在于能更好地满足用户的需要。

(2）页的大小固定且由系统决定。在采用分页存储管理方式的系统中，在硬件结构上， 就把用户程序的逻辑地址划分为页号和页内地址两部分，也就是说是直接由硬件实现的， 因而在每个系统中只能有一种大小的页面。而段的长度却不固定，决定于用户所编写的程 序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。

(3）分页的用户程序地址空间是一维的。分页完全是系统的行为，故在分页系统中， 用户程序的地址是属于单一的线性地址空间，程序员只需利用一个记忆符即可表示一个地 址。而分段是用户的行为，故在分段系统中，用户程序的地址空间是二维的，程序员在标 识一个地址时，既需给出段名，又需给出段内地址。

4.6.3信息共享 分段系统的一个突出优点，是易于实现段的共享，即允许若干个进程共享一个或多个 148  第四章存储器管理 分段，且对段的保护也十分简单易行。

1.分页系统中对程序和数据的共享 在分页系统中，虽然也能实现对程序和数据的共享，但远不如分段系统来得方便。我 们通过一个例子来说明这个问题。例如，有一个多用户系统，可同时接纳40个用户，他们 的（Reentrant)，则无论是在分页系统还是在分段系统中，该代码都能被共享，在内存中只需 保留一份文本编辑程序的副本，此时所需的内存空间仅为1760KB（40×40+160)，而不是 8000KB。假定每个页面的大小为4KB，那么，160KB的代码将占用40个页面，数据区 占10个页面。为实现代码的共享，应在每个进程的页表中都建立40个页表项，它们的物 理块号都是21#～60#。在每个进程的页表中，还须为自己的数据区建立页表项，它们的物 理块号分别是61#～70#、71#～80#、81#～90#，，等等。图4-21是分页系统中共享editor 的示意图。 进程1 页表 ed1 21 主存 ed 2 22 ： ed40 60 data1 61 Ipa ed2 ： 22 data40 70 ed40 60 进程2 页表 data 1 61 ed1 21 ： ed 2 22 data10 70 ： data 1 71 ed 40 60 data1 71 data10 data40 80 图4-21分页系统中共享editor的示意图

2.分段系统中程序和数据的共享 在分段系统中，由于是以段为基本单位的，不管该段有多大，我们都只需为该段设置 一个段表项，因此使实现共享变得非常容易。我们仍以共享editor为例，此时只需在（每个） 进程1和进程2的段表中，为文本编辑程序设置一个段表项，让段表项中的基址(80)指向 editor程序在内存的起始地址。图4-22是分段系统中共享editor的示意图。 可重入代码(ReentrantCode)又称为“纯代码”（PureCode)，是一种允许多个进程同时 访问的代码。为使各个进程所执行的代码完全相同，绝对不允许可重入代码在执行中有任 何改变。因此，可重入代码是一种不允许任何进程对它进行修改的代码。但事实上，大多 149  计算机操作系统 数代码在执行时都可能有些改变，例如，用于控制程序执行次数的变量以及指针、信号量 及数组等。为此，在每个进程中，都必须配以局部数据区，把在执行中可能改变的部分拷 贝到该数据区，这样，程序在执行时，只需对该数据区(属于该进程私有)中的内容进行修 改，并不去改变共享的代码，这时的可共享代码即成为可重入代码。 段表 进程1 段长 基址 80 editor editor 160 80 240 data 1 data 1 40 240 280 ： 进程2 380 editor 160 data2 80 420 data2 40 380 ： 图4-22分段系统中共享editor的示意图

4.6.4段页式存储管理方式 分页系统以页面作为内存分配的基本单位，能有效地提高内存利用率，而分段系统以 段作为内存分配的基本单位，它能够更好地满足用户多方面的需要。如果能对两种存储管 理方式“各取所长”，则可形成一种新的存储器管理方式一段页式存储管理方式。这种新 的系统既具有分段系统的便于实现、分段可共享、易于保护、可动态链接等一系列优点， 又能像分页系统那样，很好地解决内存的外部碎片问题。

1.基本原理 段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再 把每个段分成若干个页，并为每一个段赋予一个段名。图4-23（a)示出了一个作业地址空间 的结构。该作业有三个段：主程序段、子程序段和数据段；页面大小为4KB。在段页式系 统中，其地址结构由段号、段内页号及页内地址三部分所组成，如图4-23(b)所示。 主程序段 子程序段 数据段 00 0 0 4K 4K 4K 8K 8K 10K 12K 12K 15K 16K (a) 段号(S) 段内页号(P) 页内地址（W) (b) 图4-23作业地址空间和地址结构 在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中需要同时配置段表 和页表。段表的内容与分段系统略有不同，它不再是内存始址和段长，而是页表始址和页 表长度。图4-24示出了利用段表和页表进行从用户地址空间到物理（内存)空间的映射。 150  第四章存储器管理 操作系统 段表寄存器 页号状态存储块# 段表大小段表始址 0 1 。 2 1 段号状态页表大小页表始址 3 0 4 0 1 2 3 0 页号状态存储块# 4 1 段表 + ? 页表 主存 图4-24利用段表和页表实现地址映射

2.地址变换过程 在段页式系统中，为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始 址和段长TL。进行地址变换时，首先利用段号S，将它与段长TL进行比较。若S<TL， 表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中 得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中 读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。图4-25示出了段 页式系统中的地址变换机构。 地址越界 段表寄存器 逻辑地址 段表始址 段表长度 段号S 页号P 页内地址W 段表 页表 01 0 1 2 3 b W 物理地址 图4-25段页式系统中的地址变换机构 在段页式系统中，为了获得一条指令或数据，须三次访问内存。第一次访问是访问内 存中的段表，从中取得页表始址；第二次访问是访问内存中的页表，从中取出该页所在的 物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正 从第二次访问所得的地址中取出指令或数据。 显然，这使访问内存的次数增加了近两倍。为了提高执行速度，在地址变换机构中增 设一个高速缓冲寄存器。每次访问它时，都须同时利用段号和页号去检索高速缓存，若找 151  计算机操作系统 到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成物理地址；若 未找到匹配表项，则仍需第三次访问内存。由于它的基本原理与分页及分段的情况相似， 故在此不再赘述。

1.为什么要配置层次式存储器？

2.可采用哪几种方式将程序装入内存？它们分别适用于何种场合？

3.何谓静态链接？静态链接时需要解决两个什么问题？

4.何谓装入时动态链接？装入时动态链接方式有何优点？

5.何谓运行时动态链接？运行时动态链接方式有何优点？

6.在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？

7.为什么要引入动态重定位？如何实现？

8.什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？

9.在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？

10.什么是基于索引搜索的动态分区分配算法？它可分为哪几种？

11.令buddyk(x)为大小为2k、地址为x的块的伙伴系统地址，试写出buddyk(x)的通用 表达式。

12.分区存储管理中常用哪些分配策略？比较它们的优缺点。

13.为什么要引入对换？对换可分为哪几种类型？

14.对文件区管理的目标和对对换空间管理的目标有何不同？

15.为实现对换，系统应具备哪几方面的功能？

16.在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？

17.基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？

18.什么是页面？什么是物理块？页面的大小应如何确定？

19.什么是页表？页表的作用是什么？

20.为实现分页存储管理，需要哪些硬件支持？

21.在分页系统中是如何实现地址变换的？

22.具有快表时是如何实现地址变换的？

23.较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。

24.在具有快表的段页式存储管理方式中，如何实现地址变换？

25.为什么说分段系统比分页系统更易于实现信息的共享和保护？

26.分页和分段存储管理有何区别？

27.试全面比较连续分配和离散分配方式。 152