计算机操作系统 每当用户进程发出打印输出请求时，假脱机打印机系统并不是立即把打印机分配给该 用户进程，而是由假脱机管理进程完成两项工作：①在磁盘缓冲区中为之申请一个空闲盘 块，并将要打印的数据送入其中暂存；②为用户进程申请一张空白的用户请求打印表，并 将用户的打印要求填入其中，再将该表挂到假脱机文件队列上。在这两项工作完成后，虽 然还没有进行任何实际的打印输出，但对于用户进程而言，其打印请求已经得到满足，打 印输出任务已经完成。 真正的打印输出是假脱机打印进程负责的，当打印机空闲时，该进程首先从假脱机文 内存缓冲区，再交付打印机进行打印。一个打印任务完成后，假脱机打印进程将再次查看 假脱机文件队列，若队列非空，则重复上述的工作，直至队列为空。此后，假脱机打印进 程将自己阻塞起来，仅当再次有打印请求时，才被重新唤醒运行。 由此可见，利用假脱机系统向用户提供共享打印机的概念是：对每个用户而言，系统 并非即时执行其程序输出数据的真实打印操作，而只是即时将数据输出到缓冲区，这时的 数据并未真正被打印，只是让用户感觉系统已为他打印；真正的打印操作，是在打印机空 一个时间片，没有使用专门的外围机；以上的过程是对用户屏蔽的，用户是不可见的。

5.守护进程（daemon） 前面是利用假脱机系统来实现打印机共享的一种方案，人们对该方案进行了某些修改， 如取消该方案中的假脱机管理进程，为打印机建立一个守护进程，由它执行一部分原来由 假脱机管理进程实现的功能，如为用户在磁盘缓冲区中申请一个空闲盘块，并将要打印的 数据送入其中，将该盘块的首址返回给请求进程。另一部分由请求进程自己完成，每个要 求打印的进程首先生成一份要求打印的文件，其中包含对打印的要求和指向装有打印输出 数据盘块的指针等信息，然后将用户请求打印文件放入假脱机文件队列（目录）中。 守护进程是允许使用打印机的唯一进程。所有需要使用打印机进行打印的进程都需将 一份要求打印的文件放在假脱机文件队列（目录）中。如果守护进程正在睡眠，便将它唤醒， 由它按照目录中第一个文件中的说明进行打印，打印完成后，再按照目录中第二个文件中 的说明进行打印，如此逐份文件地进行打印，直到目录中的全部文件打印完毕，守护进程 无事可做，又去睡眠。等待用户进程再次发来打印请求。 除了打印机守护进程之外，还可能有许多其它的守护进程，如服务器守护进程和网络 守护进程等。事实上，凡是需要将独占设备改造为可供多个进程共享的设备时，都要为该 设备配置一个守护进程和一个假脱机文件队列（目录）。同样，守护进程是允许使用该独占 设备的唯一进程，所有其它进程都不能直接使用该设备，只能将对该设备的使用要求写入 一份文件中，放在假脱机目录中。由守护进程按照目录中的文件依次来完成诸进程对该设 备的请求，这样就把一台独占设备改造为可为多个进程共享的设备。

6.7缓冲区管理 在现代操作系统中，几乎所有的IVO设备在与处理机交换数据时都用了缓冲区。缓冲 208  第六章输入输出系统 区是一个存储区域，它可以由专门的硬件寄存器组成，但由于硬件的成本较高，容量也较 小，一般仅用在对速度要求非常高的场合，如存储器管理中所用的联想存储器；设备控制 器中用的数据缓冲区等。在一般情况下，更多的是利用内存作为缓冲区。本节所要介绍的 也正是由内存组成的缓冲区。缓冲区管理的主要功能是组织好这些缓冲区，并提供获得和 释放缓冲区的手段。

6.7.1缓冲的引入 -→ 引入缓冲区的原因有很多，可归结为以下几点：

（1）缓和CPU与I/O设备间速度不匹配的矛盾。 事实上，凡在数据到达速率与其离去速率不同的地方，都可设置缓冲区，以缓和它们 之间速率不匹配的矛盾。众所周知，CPU的运算速率远远高于I/O设备的速率，如果没有 缓冲区，在输出数据时，必然会由于打印机的速度跟不上，而使CPU停下来等待；然而在 计算阶段，打印机又空闲无事。如果在打印机或控制器中设置一缓冲区，用于快速暂存程 序的输出数据，以后由打印机“慢慢地”从中取出数据打印，这样，就可提高CPU的工作 效率。类似地，在输入设备与CPU之间设置缓冲区，也可使CPU的工作效率得以提高。

(2）减少对CPU的中断频率，放宽对CPU中断响应时间的限制。 在远程通信系统中，如果从远地终端发来的数据仅用一位缓冲来接收，如图6-22（a）所 示，则必须在每收到一位数据时便中断一次CPU，这样，对于速率为9.6kb/s的数据通信 来说，就意味着其中断CPU的频率也为9.6kb/s，即每100us就要中断CPU一次，而且 CPU必须在100us内予以响应，否则缓冲区内的数据将被冲掉。倘若设置一个具有8位的 缓冲（移位)寄存器，如图6-22(b)所示，则可使CPU被中断的频率降低为原来的1/8：若再 设置一个8位寄存器，如图6-22（c）所示，则又可把CPU对中断的响应时间从100us放宽 到800μus。类似地，在磁盘控制器和磁带控制器中，都需要配置缓冲寄存器，以减少对CPU 的中断频率，放宽对CPU中断响应时间的限制。随着传输速率的提高，需要配置位数更多 的寄存器进行缓冲。 (a) 8位缓冲寄存器 (b) 送内存 8位缓冲寄存器 (#) 智送内存 图6-22利用缓冲寄存器实现缓冲

(3）解决数据粒度不匹配的问题。 缓冲区可用于解决在生产者和消费者之间交换的数据粒度(数据单元大小)不匹配的问 题。例如，生产者所生产的数据粒度比消费者消费的数据粒度小时，生产者进程可以一连 生产好几个数据单元的数据，当其总和已达到消费者进程所要求的数据单元大小时，消费 209  计算机操作系统 者便可从缓冲区中取出消费。反之，如果生产者所生产的数据粒度比消费者消费的数据粒 度大时，生产者每次生产的数据消费者可以分几次从缓冲区中取出消费。

（4）提高CPU和I/O设备之间的并行性。 设备的利用率。例如，在CPU（生产者）和打印机（消费者）之间设置了缓冲区后，生产者在生 产了一批数据并将它放入缓冲区后，便可立即去进行下一次的生产。与此同时，消费者可 以从缓冲区中取出数据消费，这样便可使CPU与打印机处于并行工作状态。

6.7.2单缓冲区和双缓冲区 如果在生产者与消费者之间未设置任何缓冲，生产者与消费者之间在时间上会相互限 制。例如，生产者已经完成了数据的生产，但消费者尚未准备好接收，生产者无法把所生 产的数据交付给消费者，此时生产者必须暂停等待，直到消费者就绪。如果在生产者与消 费者之间设置了一个缓冲区，则生产者无需等待消费者就绪，便可把数据输出到缓冲区。

1.单缓冲区（SingleBuffer) 在单缓冲情况下，每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一 缓冲区，如图6-23所示。在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为 T，OS将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理（计算） 的时间为C。由于T和C是可以并行的（见图6-23)，当T>C时，系统对每一块数据的处 理时间为M+T；反之则为M+C，敌可把系统对每一块数据的处理时间表示为Max（C，T)+M。 用户进程 处理(C) 传送(M) 输入(T) (a) 工作区」 缓冲区 VO设备 T1 T2 T (b) M M M C 图6-23单缓冲工作示意图 在字符设备输入时，缓冲区用于暂存用户输入的一行数据，在输入期间，用户进程被 挂起以等待数据输入完毕；在输出时，用户进程将一行数据输入到缓冲区后继续进行处理。 当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应 阻塞。

2.双缓冲区（DoubleBuffer) 由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。如果消费者尚未 取走缓冲区中的数据，即使生产者又生产出新的数据，也无法将它送入缓冲区，生产者等 待。如果为生产者与消费者设置了两个缓冲区，便能解决这一问题。 210  第六章：输入输出系统 为了加快输入和输出速度，提高设备利用率，人们又引入了双缓冲区机制，也称为缓 冲对换(BufferSwapping)。在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓 冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程（见图6-24)。接着由 CPU对数据进行计算。在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C,T)， 如果C<T，可使块设备连续输入；如果C>T，则可使CPU不必等待设备输入。对于字符 设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间，即用户在输入完第 一行后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。 用户进程 缓冲区1 工作区 二I/O设备 (a) 缓冲区2 缓冲1 缓冲2 缓冲3 缓冲4 T T2 T, T (b) M2 M C C2 图6-24双缓冲工作示意图 如果在实现两台机器之间的通信时仅为它们配置了单缓冲，如图6-25（a)所示，那么， 它们之间在任一时刻都只能实现单方向的数据传输。例如，只允许把数据从A传送到B， 或者从B传送到A，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须 在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区，如图 6-25(b)所示。 A机 B机 A机 B机 接收 发送 缓冲区 缓冲区 缓冲区 缓冲区 接收 发送 缓冲区 缓冲区 (a)单缓冲 (b)双缓冲 图6-25双机通信时缓冲区的设置

6.7.3环形缓冲区 当输入与输出的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消 费者基本上能并行操作。但若两者的速度相差甚远，双缓冲的效果则不够理想，不过可以 随着缓冲区数量的增加，使情况有所改善。因此，又引入了多缓冲机制，可将多个缓冲区 组织成环形缓冲区形式。

1.环形缓冲区的组成

(1）多个缓冲区。在环形缓冲中包括多个缓冲区，其每个缓冲区的大小相同。作为输 211  计算机操作系统 入的多缓冲区可分为三种类型：用于装输入数据的空缓冲区R、已装满数据的缓冲区G以 及计算进程正在使用的现行工作缓冲区C，如图6-26所示。 Nexti ↓I Nexti R R -G 21R G 2R G 3IGK G5 curren Nextg G G Nextg 图6-26环形缓冲区

（2）多个指针。作为输入的缓冲区可设置三个指针：用于指示计算进程下一个可用缓 冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti，以及用于指示计 算进程正在使用的缓冲区C的指针Current。

2.环形缓冲区的使用 计算进程和输入进程可利用下述两个过程来使用形环缓冲区。

（1）Getbuf过程。当计算进程要使用缓冲区中的数据时，可调用Getbuf过程。该过程 将由指针Nextg所指示的缓冲区提供给进程使用，相应地，须把它改为现行工作缓冲区， 并令Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区。类似 地，每当输入进程要使用空缓冲区来装入数据时，也调用Getbuf过程，由该过程将指针 Nexti所指示的缓冲区提供给输入进程使用，同时将Nexti指针移向下一个R缓冲区。

(2）Releasebuf过程。当计算进程把C缓冲区中的数据提取完毕时，便调用Releasebuf 过程，将缓冲区C释放。此时，把该缓冲区由当前（现行）工作缓冲区C改为空缓冲区R。 类似地，当输入进程把缓冲区装满时，也应调用Releasebuf过程，将该缓冲区释放，并改 为G缓冲区。

3.进程之间的同步问题 使用输入循环缓冲，可使输入进程和计算进程并行执行。相应地，指针Nexti和指针 Nextg将不断地沿着顺时针方向移动，这样就可能出现下述两种情况：

(1）Nexti指针追赶上Nextg指针。这意味着输入进程输入数据的速度大于计算进程处 理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用。此时，输入进程应阻塞， 直到计算进程把某个缓冲区中的数据全部提取完，使之成为空缓冲区R，并调用Releasebuf 过程将它释放时，才将输入进程唤醒。这种情况被称为系统受计算限制。

(2）Nextg指针追赶上Nexti指针。这意味着输入数据的速度低于计算进程处理数据的 速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数 据。这时，计算进程只能阻塞，直至输入进程又装满某个缓冲区，并调用Releasebuf过程 将它释放时，才去唤醒计算进程。这种情况被称为系统受IO限制。 212  第六章输入输出系统

6.7.4缓冲池(BufferPool) 上述的缓冲区是专门为特定的生产者和消费者设置的，它们属于专用缓冲。当系统较 大时，应该有许多这样的循环缓冲，这不仅要消耗大量的内存空间，而且其利用率不高。 为了提高缓冲区的利用率，目前广泛流行既可用于输入又可用于输出的公用缓冲池，在池 中设置了多个可供若干个进程共享的缓冲区。缓冲池与缓冲区的区别在于：缓冲区仅仅是 一组内存块的链表，而缓冲池则是包含了一个管理的数据结构及一组操作函数的管理机制， 用于管理多个缓冲区。

1.缓冲池的组成 据的缓冲体两部分组成。缓冲首部一般包括缓冲区号、设备号、设备上的数据块号、同步 信号量以及队列链接指针等。为了管理上的方便，一般将缓冲池中具有相同类型的缓冲区 链接成一个队列，于是可形成以下三个队列： 针L(emq)分别指向该队列的首缓冲区和尾缓冲区。

(2）输入队列inq。这是由装满输入数据的缓冲区所链成的队列。其队首指针F(inq)和 队尾指针L（inq）分别指向输入队列的队首和队尾缓冲区。

(3）输出队列outq。这是由装满输出数据的缓冲区所链成的队列。其队首指针F(outq) 和队尾指针L（outq)分别指向该队列的首、尾缓冲区。 除了上述三个队列外，还应具有四种工作缓冲区：用于收容输入数据的工作缓冲区、 用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区，以及用于提取输出数 据的工作缓冲区。

2.Getbuf过程和Putbuf过程 在数据结构课程中，曾介绍过队列和对队列进行操作的两个过程，第一个是 Addbuf(type，number)过程。该过程用于将由参数number所指示的缓冲区B挂在type队列 上。第二个是Takebuf(type)过程。它用于从type所指示的队列的队首摘下一个缓冲区。 这两个过程能否用于对缓冲池中的队列进行操作呢？答案是否定的。因为缓冲池中的 队列本身是临界资源，多个进程在访问一个队列时，既应互斥，又须同步。为此，需要对 这两个过程加以改造，以形成可用于对缓冲池中的队列进行操作的Getbuf和Putbuf过程。 为使诸进程能互斥地访问缓冲池队列，可为每一队列设置一个互斥信号量MS(type)。 此外，为了保证诸进程同步地使用缓冲区，又为每个缓冲队列设置了一个资源信号量 RS(type)。既可实现互斥又可保证同步的Getbuf过程和Putbuf过程描述如下： voidGetbuf(unsignedtype) Wait(RS(type)); Wait(MS(type)); B(number) = Takebuf(type); Signal(MS(type)); 213  计算机操作系统 void Putbuf(type, number) { Wait(MS(type)); Addbuf(type, number); Signal(MS(type); Signal(RS(type));

3.缓冲区的工作方式 缓冲区可以工作在如下四种工作方式，如图6-27所示。 缓冲池 收容输入 提取输入 hin sin 用户程序 提取输出 收容输出 hout sout 图6-27缓冲区的工作方式

(1）收容输入。输入进程可调用Getbuf(emq)过程，从空缓冲队列emq的队首摘下一空 缓冲区，把它作为收容输入工作缓冲区hin。然后，把数据输入其中，装满后再调用 Putbuf(inq，hin）过程，将它挂在输入队列inq队列上。

(2）提取输入。计算进程可调用Getbuf(inq)过程，从输入队列inq的队首取得一缓冲区， 作为提取输入工作缓冲区（sin)，计算进程从中提取数据。计算进程用完该数据后，再调用 Putbuf(emq，sin）过程，将它挂到空缓冲队列emq上。

(3）收容输出。计算进程可调用Getbuf(emq)，从空缓冲队列emq的队首取得一空缓冲， 作为收容输出工作缓冲区hout。当其中装满输出数据后，又调用Putbuf(outq，hout)过程， 将它挂在outq末尾。

（4）提取输出。输出进程可调用Getbuf（outq）过程，从输出队列的队首取得一装满输出 数据的缓冲区，作为提取输出工作缓冲区sout。在数据提取完后，再调用Putbuf(emq，sout) 过程，将它挂在空缓冲队列末尾。

6.8 磁盘存储器的性能和调度 磁盘存储器是计算机系统中的最重要的存储设备，在其中存放了大量的文件。对文件 的读、写操作都将涉及到对磁盘的访问。磁盘I/O速度的高低和磁盘系统的可靠性，将直 接影响到系统的性能。可以通过多种途经来改善磁盘系统的性能。首先可通过选择好的磁 盘调度算法，以减少磁盘的寻道时间：其次是提高磁盘IVO速度，以提高对文件的访问速 度；第三采取冗余技术，提高磁盘系统的可靠性，建立高度可靠的文件系统。第二和第三 点我们将它放在磁盘存储器管理一章中介绍。 214