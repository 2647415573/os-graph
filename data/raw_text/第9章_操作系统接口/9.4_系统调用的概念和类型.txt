

--- Page 304 ---
第九章操作系统接口
从缓冲区中读取用户输入的命令。
看命令行中的命令，对命令和分隔符进行分析，建立相应的二叉树结构命令行树。并以命
令名作为文件名，将其它参数改造为系统调用execve内部处理所要求的形式。
(3）建立相应的子进程。终端进程调用fork，为二叉树结构命令行中的每一条命令建立
相应的子进程。
（4）等待子进程完成。对于“；”型结点，需在其左子树执行完成后，才可继续处理下
一条命令。故终端进程本身需要调用系统调用Wait40来等待子进程完成。当子进程运行时
调用execve（），子进程根据文件名（即命令名)到目录中查找有关文件，将它调入内存，执行
这个程序；当子进程完成处理后终止，向父进程（终端进程）报告，此时终端进程醒来，在
做必要的判别等工作后，继续处理下一条命令重复上述处理过程。
（5）对于“&”型结点，在启动其左子结点执行后，因它是后台命令，不需要等待，因
此终端进程不用系统调用Wait4（），而是再执行其右子树。
Shell基本执行过程及父子进程之间的关系如图9-5所示。
终端进程
子进程
读入命令行
调度到
execve(）更换
进程映像
子进程
分离命令名，
按execveO的
要求放置参数
运行命令对应的
可执行文件
id-forkO
ExitO终止
创建子进程
放弃CPU
子进程
id=0?
#0
=0
父进程
无
子进程终止
有“&”？
向父进程报告
有
WaitO等待
子进程终止
发提示符“S”
图9-5Shell基本执行过程及父子进程之间的关系
系统调用的概念和类型
程序接口，是OS专门为用户程序设置的，提供给程序员在编程时使用，也是用户程
序取得OS服务的唯一途径。它是由一组系统调用（systemcall)组成，因而，也可以说，系
293

--- Page 305 ---
计算机操作系统
统调用提供了用户程序和操作系统内核之间的接口。系统调用不仅可供所有的应用程序使
用，而且也可供OS自身使用。在每个系统中，通常都有几十条甚至上百条的系统调用，
并可根据其功能把它们划分成若干类，每一个系统调用都是一个能完成特定功能的子程序。
9.4.1系统调用的基本概念
在计算机系统中，通常运行着两类程序：系统程序和应用程序。为了防止应用程序对
OS的破坏，应用程序和OS的内核是运行在不同的状态，即OS的内核是运行在系统态，
而应用程序是运行在用户态。产
1.系统态和用户态
如在2.3.1小节中所述，在计算机系统中设置了两种状态：系统态（或称为核心态）和用
户态。在实际运行过程中，处理机会在系统态和用户态间切换。相应地，现代多数OS将
CPU的指令集分为特权指令和非特权指令两类。
（1）特权指令。特权指令是指在系统态运行的指令，它对内存空间的访问范围基本不受限
制，不仅能访问用户空间，也能访问系统空间。如启动外部设备、设置系统时钟时间、关中
断、转换执行状态等。特权指令只允许OS使用，不允许应用程序使用，以避免引起系统混乱。
（2）非特权指令。非特权指令是在用户态运行的指令。应用程序所使用的都是非特权
指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，对内
存的访问范围也局限于用户空间。这样，可以防止应用程序的运行异常对系统造成破坏。
这种限制是由硬件实现的，如果在应用程序中使用了特权指令，就会发出权限出错信
号，操作系统捕获到这个信号后，将转入相应的错误处理程序，将停止该应用程序的运行，
重新调度。
2.系统调用
在OS中提供系统调用的目的，是使应用程序可以通过它间接调用OS中的相关过程，
取得相应的服务。系统调用在本质上是应用程序请求OS内核完成某功能时的一种过程调
用，但它是一种特殊的过程调用，它与一般的过程调用有下述几方面的明显差别：
（1）运行在不同的系统状态。一般的过程调用其调用程序和被调用程序运行在相同的
状态一一系统态或用户态；而系统调用与一般调用的最大区别就在于：调用程序是运行在
用户态，而被调用程序是运行在系统态。
(2）状态的转换。由于一般的过程调用并不涉及到系统状态的转换，所以可直接由调
用过程转向被调用过程。但在运行系统调用时，由于调用和被调用过程是工作在不同的系
统状态，因而不允许由调用过程直接转向被调用过程，需要通过软中断机制，先由用户态
转换为系统态，经内核分析后，才能转向相应的系统调用处理子程序。
(3）返回问题。在采用了抢占式（剥夺)调度方式的系统中，在被调用过程执行完后，要
对系统中所有要求运行的进程做优先权分析。当调用进程仍具有最高优先级时，才返回到
调用进程继续执行；否则，将引起重新调度，以便让优先权最高的进程优先执行。此时，
将把调用进程放入就绪队列。
（4）嵌套调用。像一般过程一样，系统调用也可以嵌套进行，即在一个被调用过程的
执行期间，还可以利用系统调用命令去调用另一个系统调用。当然，每个系统对嵌套调用
294

--- Page 306 ---
第九章操作系统接口
的深度都有一定的限制，例如最大深度为6。但一般的过程对嵌套的深度则没有什么限制。
图9-6示出了没有嵌套及有嵌套的两种系统调用情况。
用户程序
系统调
系统调
用命令
系统功能
用命令
系统功能
调用
调用
系统调
用命令调用系统子功能
返回
返回
返回
(a)系统调用与返回
(b）程序之间的嵌套调用
图9-6系统功能的调用
我们可以通过一个简单的例子来说明在用户程序中是如何使用系统调用的。例如，要
写一个简单的程序，用于从一个文件中读出数据，再将该数据拷贝到另一文件中。为此，
首先须输入该程序的输入文件名和输出文件名。文件名可用多种方式指定，一种方式是由
程序询问用户两个文件的名字。在交互式系统中，该方式要使用一系列的系统调用，先在
屏幕上打印出一系列的提示信息，然后从键盘终端读入定义两个文件名的字符串。
一旦获得两个文件名后，程序又必须利用系统调用open去打开输入文件，并用系统调
用creat去创建指定的输出文件；在执行open系统调用时，又可能发生错误。例如，程序
试图去打开一个不存在的文件；或者，该文件虽然存在，但并不允许被访问等。此时，程
序又须利用多条系统调用去显示出错信息，继而再利用一系统调用，去实现程序的异常终
止。类似地，在执行系统调用creat时，同样可能出现错误。例如，系统中早已有了与输出
文件同名的另一文件，这时又须利用一系统调用来结束程序；或者利用一系统调用来删除
已存在的那个同名文件，然后，再利用creat来创建输出文件。
在打开输入文件和创建输出文件都获得成功后，还须利用申请内存的系统调用alloc，
根据文件的大小，申请一个缓冲区。成功后，再利用read系统调用，从输入文件中把数据
读到缓冲区内。读完后，又用系统调用close去关闭输入文件。然后，再利用write系统调
用把缓冲区内的数据写到输出文件中。在读或写操作中，也都可能需要回送各种出错信息。
比如，在输入时，可能发现已到达文件末尾（指定的字符数尚未读够）：或者，在读过程中，
发现硬件故障（如奇、偶错）；在写操作中，可能遇见各种与输出设备类型有关的错误，比
如，已无磁盘空间，打印机缺纸等。在将整个文件拷贝完后，程序又须调用close去关闭输
出文件，并向控制台写出一消息，以指示拷贝完毕。最后，再利用一系统调用exit使程序
正常结束。由上所述可见，一个用户程序将频繁地利用各种系统调用，以取得OS所提供
的多种服务。
3.中断机制
系统调用是通过中断机制实现的，并且一个操作系统的所有系统调用，都通过同一个
中断入口来实现。如MS-DOS提供了INT21H，应用程序通过该中断获取操作系统的服务。
对于拥有保护机制的OS来说，中断机制本身也是受保护的，在IBMPC上，Intel提
供了多达255个中断号，但只有授权给应用程序保护等级的中断号，才是可以被应用程序
295

--- Page 307 ---
计算机操作系统
调用的。对于未被授权的中断号，如果应用程序进行调用，同样会引起保护异常，而导致
自己被操作系统停止。如Linux仅仅给应用程序授权了4个中断号：3，4，5，以及80h。前
三个中断号是提供给应用程序调试所使用的，而80h正是系统调用(systemcall)的中断号。
9.4.2系统调用的类型
现在所有的通用OS都提供了许多系统调用，但它们所提供的系统调用会有一定的差
异。对于一般通用的OS而言，可将系统调用分为如下三大类。
1.进程控制类系统调用
主要用于对进程控制的系统调用有：
（1）创建和终止进程的系统调用。利用创建进程的系统调用，为欲参加并发执行的程
序创建一个进程。当进程已经执行结束时，利用终止进程的系统调用来终止该进程的运行。
（2）获得和设置进程属性的系统调用。进程的属性包括有进程标识符、进程优先级、
最大允许执行时间等。利用获得进程属性的系统调用来了解某进程的属性，利用设置进程
属性的系统调用来确定和重新设置进程的属性。
(3）等待某事件出现的系统调用。进程在运行过程中，需要等待某事件（条件）出现后方
可继续执行。此时进程可利用等待（事件）的系统调用，使自己处于等待状态，一旦等待的
事件出现，便可将等待进程唤醒。
2.文件操纵类系统调用
对文件进行操纵的主要系统调用如下：
（1）创建和删除文件。利用创建文件的系统调用请求系统创建一个新文件。利用删除
文件的系统调用将指名文件删除。
（2）打开和关闭文件的系统调用。用户在第一次访问某个文件之前，应先利用打开文
件的系统调用将指名文件打开。利用关闭文件的系统调用将指定文件关闭。
(3）读和写文件的系统调用。用户可利用读系统调用从已打开的文件中读出给定数目
的字符，并送至指定的缓冲区中：也可利用写系统调用从指定的缓冲区中将给定数目的字
符写入文件中。读和写系统调用是文件操纵类中使用最频繁的系统调用。
3.进程通信类系统调用
在单处理机系统中，OS经常采用消息传递方式和共享存储区方式。当采用消息传递方
式时，在通信前需先打开一个连接。为此，应由源进程发出一条打开连接的系统调用，而
目标进程则应利用接受连接的系统调用表示同意进行通信；然后，在源和目标进程之间便
可开始通信。可以利用发送消息的系统调用或者用接收消息的系统调用来交换信息。通信
结束后，还须再利用关闭连接的系统调用结束通信。
用户在利用共享存储区进行通信之前，须先利用建立共享存储区的系统调用来建立一
个共享存储区，再利用建立连接的系统调用将该共享存储区连接到进程自身的虚地址空间
上，然后便可利用读和写共享存储区的系统调用实现相互通信。
除上述三类系统调用外，常用的系统调用还包括设备管理类系统调用和信息维护类系
统调用，前者主要用于实现申请设备、释放设备、设备I/O和重定向、获得和设置设备属
性等功能，后者主要用来获得包括有关系统和文件的时间、日期信息、操作系统版本、当
296

--- Page 308 ---
第九章操作系统接口
前用户以及有关空闲内存和磁盘空间大小等多方面的信息。
9.4.3POSIX标准
一一一←
目前许多操作系统都提供了上面所介绍的各种类型的系统调用，实现的功能也相类似，
但在实现的细节和形式方面却相差很大，这种差异给实现应用程序与操作系统平台的无关性
带来了很大的困难。为解决这一问题，国际标准化组织ISO给出的有关系统调用的国际标准
POSIX定义了标准应用程序接口（API)，用于保证编制的应用程序可以在源代码一级上
在多种操作系统上移植运行。只有符合这一标准的应用程序，才有可能完全兼容多种操作
系统，即在多种操作系统下都能够运行。
POSIX标准定义了一组过程，这组过程是构造系统调用所必须的，通过调用这些过程
所提供的服务，确定了一系列系统调用的功能。一般而言，在POSIX标准中，大多数的系
统调用是一个系统调用直接映射一个过程，但也有一个系统调用对应若干个过程的情形，如
当一个系统调用所需要的过程是其它系统调用的组合或变形时，则往往会对应多个过程。
需要明确的是，POSIX标准所定义的一组过程虽然指定了系统调用的功能，但并没有
明确规定系统调用以什么形式实现，是库函数还是其它形式。如早期操作系统的系统调用
使用汇编语言编写，这时的系统调用可看成扩展的机器指令，因而，能在汇编语言编程中
直接使用。而在一些高级语言或C语言中，尤其是最新推出的一些操作系统，如UNIX新
版本、Linux、Windows和OS/2等，其系统调用干脆用C语言编写，并以库函数形式提供，
所以在用C语言编制的应用程序中，可直接通过使用对应的库函数来使用系统调用，库函
数的目的是隐藏访管指令的细节，使系统调用更像过程调用。但一般地说，库函数属于用
户程序而非系统调用程序。如图9-7示出了UNIX/Linux的系统程序、库函数、系统调用的
层次关系。
用户接口
用户
库函数接口
标准系统程序（实用程序）
系统程序：汇编、编译、编辑、Shell
系统调用接口
标准库函数
标准函数：打开、关闭、读、写、创建、撤销
操作系统
系统调用：进程管理、有储管理、文件管理、设备管理
图9-7UNIX/Linux系统程序、库函数、系统调用的分层关系
9.5
UNIX系统调用
在上一节中，我们对系统调用做了一般性的描述。为使读者能对系统调用有较具体的
297