

--- Page 311 ---
计算机操作系统
(2）共享存储器机制。当用户(进程)要利用共享存储器机制进行通信时，必须先利用
shmget系统调用来建立一个共享存储区，若成功，便返回该共享存储区描述符shmid。以
后，用户便可利用shmid去访问该共享存储区。进程在建立了共享存储区之后，还必须再
利用shmat将该共享存储区连接到本进程的虚地址空间上。以后，在进程之间便可利用该
共享存储区进行通信。当进程不再需要该共享存储区时，可利用shmdt系统调用来拆除进
程与共享存储区间的连接。
2.信息维护
在UNIX系统中，设置了许多条用于系统维护的系统调用，下面介绍常用的几条。
（1）设置和获得时间。超级用户可利用设置时间的系统调用（stime）来设置系统的日期和
时间：如果调用进程并非超级用户，则stime失败；一般用户可利用获得时间的系统调用
time来获得当前的日期和时间。
(2）获得进程和子进程时间（times)。利用该系统调用可获得进程及其子进程所使用的
CPU时间，其中包括调用进程在用户空间执行指令所花费的时间，系统为调用进程所花费
的CPU时间，子进程在用户空间所用的CPU时间，系统为各子进程所花费的CPU时间等，
并可将这些时间填写到一个指定的缓冲区。
（3）设置文件访问和修改时间（utime)。该系统调用用于设置指名文件被访问和修改的
时间。如果该系统调用的参数times为NULL，则文件主和对该文件具有写权限的用户可
将对该文件的访问和修改时间设置为当前时间；如果times不为NULL，则把times解释
为指向utimbuf结构的指针，此时，文件主和超级用户能将访问时间和修改时间置入utim
buf结构中。
（4）获得当前UNIX系统的名称（uname)。利用该系统调用可将有关UNIX系统的信息
存储在utsname结构中。这些信息包括UNIX系统名称的字符串、系统在网络中的名称、硬
件的标准名称等。
/9.6系统调用的实现
系统调用的实现与一般过程调用的实现相比，两者间有很大差异。对于系统调用，控
制是由原来的用户态转换为系统态，这是借助于陷入机制来完成的，在该机制中包括陷入
硬件机构及陷入处理程序两部分。当应用程序使用OS的系统调用时，产生一条相应的指
令，CPU在执行这条指令时发生中断，并将有关信号送给中断和陷入硬件机构，该机构收
到信号后，启动相关的陷入处理程序进行处理，实现该系统调用所需要的功能。
9.6.1系统调用的实现方法
一一一←
1.系统调用号和参数的设置
号。在系统调用命令（陷入指令）中把相应的系统调用号传递给中断和陷入机制的方法有很
300

--- Page 312 ---
第九章操作系统接口
多，在有的系统中，直接把系统调用号放在系统调用命令(陷入指令)中，如IBM370和早
期的UNIX系统，是把系统调用命令的低8位用于存放系统调用号；在另一些系统中，则
将系统调用号装入某指定寄存器或内存单元中，如MS-DOS是将系统调用号放在AH寄存
每一条系统调用都含有若干个参数，在执行系统调用时，如何设置系统调用所需的参
数，即如何将这些参数传递给陷入处理机构和系统内部的子程序（过程），常用的实现方式
有以下儿种：
（1）陷入指令自带方式。陷入指令除了携带一个系统调用号外，还要自带几个参数进
入系统内部，由于一条陷入指令的长度是有限的，因此自带的只能是少量的、有限的参数。
(2）直接将参数送入相应的寄存器中。MS-DOS便是采用的这种方式，即用MOV指
令将各个参数送入相应的寄存器中。系统程序和应用程序都可以对这些寄存器进行访问。
这种方式的主要问题是这种寄存器数量有限，限制了所设置参数的数目。
(3）参数表方式。将系统调用所需的参数放入一张参数表中，再将指向该参数表的指
针放在某个指定的寄存器中。当前大多数的OS中，如UNIX系统和Linux系统，便是采
用了这种方式。该方式又可进一步分成直接方式和间接方式，如图9-8所示。在直接参数
方式中，所有的参数值和参数的个数N都放入一张参数表中；而在间接参数方式中，则在
参数表中仅存放参数个数和指向真正参数数据表的指针。
变元表：
变元表：
N
trap XX
N
参数1
指针
参数1
参数2
参数2
：
参数n
参数n
(a)直接方式
(b)间接方式
图9-8系统调用的参数形式
2.系统调用的处理步骤
在设置了系统调用号和参数后，便可执行一条系统调用命令。不同的系统可采用不同
的执行方式。在UNIX系统中，是执行CHMK命令；而在MS-DOS中则是执行INT21软
中断。系统调用的处理过程可分成以下三步：
首先，将处理机状态由用户态转为系统态；之后，由硬件和内核程序进行系统调用的
一般性处理，即首先保护被中断进程的CPU环境，将处理机状态字PSW、程序计数器PC、
系统调用号、用户栈指针以及通用寄存器内容等压入堆栈；然后，将用户定义的参数传送
到指定的地址并保存起来。
其次，分析系统调用类型，转入相应的系统调用处理子程序。为使不同的系统调用能
方便地转向相应的系统调用处理子程序，在系统中配置了一张系统调用入口表。表中的每
个表日都对应一条系统调用，其中包含该系统调用自带参数的数目、系统调用处理子程序
301

--- Page 313 ---
计算机操作系统
的入口地址等。因此，核心可利用系统调用号去查找该表，即可找到相应处理子程序的入
口地址而转去执行它。
最后，在系统调用处理子程序执行完后，应恢复被中断的或设置新进程的CPU现场，
然后返回被中断进程或新进程，继续往下执行。
3.系统调用处理子程序的处理过程
系统调用的功能主要是由系统调用子程序来完成的。对于不同的系统调用，其处理程
序将执行不同的功能。我们以一条在文件操纵中常用的Creat命令为例来说明之。
进入Creat的处理子程序后，核心将根据用户给定的文件路径名Path，利用目录检索
过程去查找指定文件的目录项。查找目录的方式可以用顺序查找法，也可用Hash查找法。
如果在文件目录中找到了指定文件的目录项，表示用户要利用一个已有文件来建立一个新
文件。但如果在该已有（存)文件的属性中有不允许写属性，或者创建者不具有对该文件进
行修改的权限，便认为是出错而做出错处理；若不存在访问权限问题，便将已存文件的数
据盘块释放掉，准备写入新的数据文件。如未找到指名文件，则表示要创建一个新文件，
核心便从其目录文件中找出一个空目录项，并初始化该目录项，包括填写文件名、文件属
性、文件建立日期等，然后将新建文件打开。
9.6.2UNIX系统调用的实现
在UNIX系统V的内核程序中，有一个trap.S文件，它是中断和陷入总控程序。该程
序用于中断和陷入的一般性处理。为提高运行效率，该文件采用汇编语言编写。由于在trap.S
中包含了绝大部分的中断和陷入向量的入口地址，因此，每当系统发生了中断和陷入情况
时，通常都是先进入trap.S程序，由它先处理有关CPU环境保护的问题。
另外还有一个处理各种陷入情况的C语言文件，即trap.C程序，共有12种陷入的处
理要调用trap.C程序（如系统调用、进程调度中断、跟踪自陷非法指令、访问违章、算术自
陷等)用于处理在中断和陷入发生后需要处理的若干公共问题。如果因系统调用进入trap.C，
它所要进行的处理将包括：确定系统调用号、实现参数传送、转入相应的系统调用处理子
程序。在由系统调用处理子程序返回到trap.C后，重新计算进程的优先级，对收到的信号
进行处理等。
1.CPU环境保护
当用户程序处在用户态，且在执行系统调用命令（即CHMIK命令）之前，应在用户空间
提供系统调用所需的参数表，并将该参数表的地址送入R寄存器。在执行CHMK命令后，
处理机将由用户态转为核心态，并由硬件自动地将处理机状态长字(PSL)、程序计数器（PC）
然后便转入中断和陷入总控程序trap.s中执行。
trap.S程序执行后，继续将陷入类型type和用户栈指针usp压入用户核心栈，接着还
要将被中断进程的CPU环境中的一系列寄存器如Ro～Rn的部分或全部内容压入栈中。
至于哪些寄存器的内容要压入栈中，这取决于特定寄存器中的屏蔽码，该屏蔽码的每一
位都与Ro～R11中的一个寄存器相对应。当某一位置成1时，表示对应寄存器的内容应压
入栈中。
302

--- Page 314 ---
第九章操作系统接口
2.AP和FP指针
为了实现系统调用的嵌套使用，在系统中还设置了两个
AP
指针，其一是系统调用参数表指针AP，用于指示正在执行
FP
由中断和
的系统调用所需参数表的地址，通常是把该地址放在某个寄
Ro
陷入总控
存器中，例如放在R12中；再者，还须设置一个调用栈帧指
程序压入
针。所谓调用栈帧(或简称栈帧)，是指每个系统调用需要保
Rn
存而被压入用户核心栈的所有数据项：而栈帧指针FP则是
usp
用于指示本次系统调用所保存的数据项。每当出现新的系统
type
陷入时由
调用时，还须将AP和FP303压入栈中，图9-9示出了在trap.S
code
硬件压入
总控程序执行后用户核心栈的情况。
PC
当trap.S完成被中断进程的CPU环境和AP及FP指针
PSL
的保存后，将会调用由C语言书写的公共处理程序trap.C，
用户核心栈
以继续处理本次的系统调用所要完成的公共处理部分。
图9-9用户核心栈
3.确定系统调用号
由上所述得知，在中断和陷入发生后，应先经硬件陷入机构予以处理，再进入中断和
陷入总控程序trap.S，在保护好CPU现场后再调用trap.C继续处理。其调用形式为：
trap(usp，type,code,，PC，PSL)
其中，参数PSL为陷入时处理机状态字长，PC为程序计数器，code 为代码操作数，type
为陷入类型号，uSp为用户栈指针。对陷入的处理可分为多种情况，如果陷入是由于系统调
用所引起的，则对此陷入的第一步处理便是确定系统调用号。通常，系统调用号包含在代
码操作数中，故可利用code来确定系统调用号i。其方法是：令
i=code&0377
若0<i<64，此i便是系统调用号，可根据系统调用号i和系统调用定义表，转向相应的
处理子程序。若i=0，则表示系统调用号并未包含在代码操作数中，此时应采用间接参数
方式，利用间接参数指针来找到系统调用号。
4.参数传送
参数传送是指由trap.C程序将系统调用参数表中的内容从用户区传送到User结构的
U.U-arg中，供系统调用处理程序使用。由于用户程序在执行系统调用命令之前已将参数表
的首址放入Ro寄存器中，在进入trap.C程序后，该程序便将该首址赋予U.U-arg指针，因
此，trap.C在处理参数传送时，可读取该指针的内容，以获得用户所提供的参数表，并将
之送至U.U-arg中。应当注意，对不同的系统调用所需传送参数的个数并不相同，trap.C程
5.利用系统调用定义表转入相应的处理程序
在UNIX系统中，对于不同(编号)的系统调用，都设置了与之相应的处理子程序。为
使不同的系统调用能方便地转入其相应的处理子程序，也将各处理子程序的入口地址放入
了系统调用定义表即Sysent切中。该表实际上是一个结构数组，在每个结构中包含三个元素，
参数个数；第三个元素是相应系统调用处理子程序的入口地址。在系统中设置了该表之后，
303

--- Page 315 ---
计算机操作系统
便可根据系统调用号1从系统调用定义表中找出相应的表目，再按照表目中的入口地址转
入相应的处理子程序，由该程序去完成相应系统调用的特定功能。在该子程序执行完后，
仍返回到中断和陷入总控程序中的trap.C程序中，去完成返回到断点前的公共处理部分。
6.系统调用返回前的公共处理
在UNIX系统中，进程调度的主要依据是进程的动态优先级。随着进程执行时间的加
长，其优先级将逐步降低。每当执行了系统调用命令并由系统调用处理子程序返回到trap.C
后，都将重新计算该进程的优先级；另外，在系统调用执行过程中，若发生了错误使进程
无法继续运行时，系统会设置再调度标志。处理子程序在计算了进程的优先级后，又去检
查该再调度标志是否已又被设置。若已设置，便调用switch调度程序，再去从所有的就绪
进程中选择优先级最高的进程，把处理机让给该进程去运行。
UNIX系统规定，当进程的运行是处于系统态时，即使再有其它进程又发来了信号，
也不予理踩；仅当进程已从系统态返回到用户态时，内核才检查该进程是否已收到了由其
它进程发来的信号。若有信号，便立即按该信号的规定执行相应的动作。在从信号处理程
序返回后，还将执行一条返回指令RET，该指令将把已被压入用户核心栈中的所有数据（如
PSL、PC、FP及AP等）都退还到相应的寄存器中，这样，即可将CPU控制权从系统调用
返回到被中断进程，后者继续执行下去。
9.6.5Linux系统调用
与UNIX相似，Linux采用类似技术实现系统调用。Linux系统在CPU的保护模式下
内核态）和“特权级3”（即用户态）。用户对系统调用不能任意拦截和修改，以保证内核的
安全性。Linux最多可以有190个系统调用。应用程序和Shell需要通过系统调用机制访问
Linux内核（功能)。每个系统调用由两部分组成：
（1）内核函数：是实现系统调用功能的（内核）代码，作为操作系统的核心驻留在内存中，
是一种共享代码，用C语言书写。它运行在内核态，数据也存放在内核空间，通常它不能
再使用系统调用，也不能使用应用程序可用的库函数。
（2）接口函数：是提供给应用程序的API，以库函数形式存在Linux的lib.a中，该库
中存放了所有系统调用的接口函数的目标代码，用汇编语言书写。其主要功能是：把系
统调用号、入口参数地址传送给相应的核心函数，并使用户态下运行的应用程序陷入核
心态。
Linux中有一个用汇编写的系统调用入口程序entry(sys_call_table)，它包含了系统调用
入口地址表，给出了所有系统调用核心函数的名字，而每个系统调用核心函数的编号由
include/asm/unistd.h定义：
ENTRY(sys-call-table)
longSYMBOL_NAME(sys_xxx)i
Linux的系统调用号就是系统调用入口表中位置的序号。所有系统调用通过接口函数
将系统调用号传给内核，内核转入系统调用控制程序，再通过调用号位置来定位核心函数。
Linux内核的陷入由0x80（int80h)中断实现。
304

--- Page 316 ---
第九章操作系统接口
系统调用控制程序的工作流程为：①取系统调用号，检验合法性；②执行int80h产
生中断；③进行地址空间的转换，以及堆栈的切换，进入内核态；④进行中断处理，根
据系统调用号定位内核函数地址；③根据通用寄存器内容，从用户栈中取入口参数；④核
心函数执行，把结果返回应用程序。
9.6.6Win32的应用程序接口
首先需要说明的是应用程序接口（API)与系统调用的区别和联系。API是一个函数的定
义，说明如何获得一个给定的服务，而系统调用是通过中断向内核发出的一个请求。一个
API函数可能不与任何系统调用相对应，也可以调用若干个系统调用，不同的API函数可
能封装了相同的系统调用。
Windows系统在程序设计模式上与UNIX以及Linux系统有着根本的不同。Windows
程序采用的是事件驱动方式，即主程序等待事件的发生，如鼠标的点击、键盘的敲击或一
个USB部件的插入等，然后根据事件内容，调用相应的程序进行处理。因此，在Windows
系统中，定义了一系列的程序，称为Win32API(Application Programming interface)，用来提
供操作系统的服务。
通过对Win32API的调用，可以创建各种核心对象，如文件、进程、线程、管道等。
每次调用，创建一个对象，并将对象句柄返回给调用者。这个句柄是指向对象表的索引，
它是该对象的标识，通过句柄的地址，可以间接地知道对象在内存中的具体位置，因此可
用来对对象进行操作。一般句柄不能直接传递给其它进程使用，但在特定的环境下，可以
通过复制并受保护的方式传递给其它进程，实现对象的共享。每个对象都有一个安全描述
符，详细地描述了所有可以访问该对象的应用程序以及其访问权限。
能起关键作用的操作系统程序才能运行在核心态，如对象与安全管理器、线程与进程管理
器、虚存管理器、高速缓存管理器、文件系统等，这些程序构成了操作系统的执行体
(executive)。
在Intelx86处理机上，当应用程序（用户态的执行线程）调用操作系统服务时，都要执
行int2E指令，由硬件产生一个陷入信号，引发系统服务调度的产生。陷入信号被系统捕
入处理程序的系统服务调度程序。该程序首先关中断，保存中断现场和检查参数，将调用
参数从用户态堆栈复制到核心态堆栈，并通过查找“系统服务调度表”中的系统服务信息
获得给定服务，该表就是在前面介绍的陷入向量表。表中每个入口包含一个指向相应的系
统服务程序的指针。最后，系统服务调度程序把控制权转交给执行体中相应的系统服务程
序进行处理。
在Windows 系统中，通过Kernel、User和GUI三个组件来支持API。Kernel包含了
大多数操作系统函数，如内存管理、进程管理：User集中了窗口管理函数，如窗口创建、
撤销、移动、对话及各种相关函数；GUI提供画图函数、打印函数。所有应用程序都共享
这三个模块的代码，每个Windows的API函数都可通过名字来访问。具体做法是，在应用
程序中使用函数名，并用适当的函数库进行编译和链接，然后，应用程序便可运行。实际
上，Windows将三个组件置于动态链接库DLL(DynamicLinkLibrary)中。
305

--- Page 317 ---
计算机操作系统
1.操作系统用户接口中包括哪几种接口？它们分别适用于哪种情况？
2.什么是WIMP技术？它被应用到何种场合？
3.联机命令通常有哪几种类型？每种类型中包括哪些主要命令？
4.什么是输入输出重定向？举例说明之。
5.何谓管道联接？举例说明之。
6.为了将已存文件改名，应用什么UNIX命令？
7.要想将工作目录移到目录树的某指定结点上，应使用什么命令？
8.如果希望把file1的内容附加到原有的文件file2的末尾，应用什么命令？
9.试比较mail和write命令的作用有何不同。
10.联机命令接口由哪几部分组成？
11.终端设备处理程序的主要作用是什么？它具有哪些功能？
12.命令解释程序的主要功能是什么？
13.试说明MS-DOS的命令处理程序COMMAND.COM的工作流程。
14.Shell命令有何特点？它对命令解释程序有何影响。
15.试举例说明如何建立二叉树结构的命令行树。
16.试比较一般的过程调用与系统调用。
17.系统调用有哪几种类型？
18.如何设置系统调用所需的参数？
19.试说明系统调用的处理步骤。
20.为什么在访问文件之前，要用open系统调用先打开该文件？
21.在UNIX系统中是否设置了专门用来删除文件的系统调用？为什么？
22.在IPC软件包中包含哪几种通信机制？在每种通信机制中设置了哪些系统调用？
23.trap.S是什么程序？它完成哪些主要功能？
24.在UNIX系统内，被保护的CPU环境中包含哪些数据项？
25.trap.C是什么程序？它将完成哪些处理？
26.为方便转入系统调用处理程序，在UNIX系统中配置了什么样的数据结构？
306