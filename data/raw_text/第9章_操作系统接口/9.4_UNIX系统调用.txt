

--- Page 308 ---
第九章操作系统接口
前用户以及有关空闲内存和磁盘空间大小等多方面的信息。
9.4.3POSIX标准
一一一←
目前许多操作系统都提供了上面所介绍的各种类型的系统调用，实现的功能也相类似，
但在实现的细节和形式方面却相差很大，这种差异给实现应用程序与操作系统平台的无关性
带来了很大的困难。为解决这一问题，国际标准化组织ISO给出的有关系统调用的国际标准
POSIX定义了标准应用程序接口（API)，用于保证编制的应用程序可以在源代码一级上
在多种操作系统上移植运行。只有符合这一标准的应用程序，才有可能完全兼容多种操作
系统，即在多种操作系统下都能够运行。
POSIX标准定义了一组过程，这组过程是构造系统调用所必须的，通过调用这些过程
所提供的服务，确定了一系列系统调用的功能。一般而言，在POSIX标准中，大多数的系
统调用是一个系统调用直接映射一个过程，但也有一个系统调用对应若干个过程的情形，如
当一个系统调用所需要的过程是其它系统调用的组合或变形时，则往往会对应多个过程。
需要明确的是，POSIX标准所定义的一组过程虽然指定了系统调用的功能，但并没有
明确规定系统调用以什么形式实现，是库函数还是其它形式。如早期操作系统的系统调用
使用汇编语言编写，这时的系统调用可看成扩展的机器指令，因而，能在汇编语言编程中
直接使用。而在一些高级语言或C语言中，尤其是最新推出的一些操作系统，如UNIX新
版本、Linux、Windows和OS/2等，其系统调用干脆用C语言编写，并以库函数形式提供，
所以在用C语言编制的应用程序中，可直接通过使用对应的库函数来使用系统调用，库函
数的目的是隐藏访管指令的细节，使系统调用更像过程调用。但一般地说，库函数属于用
户程序而非系统调用程序。如图9-7示出了UNIX/Linux的系统程序、库函数、系统调用的
层次关系。
用户接口
用户
库函数接口
标准系统程序（实用程序）
系统程序：汇编、编译、编辑、Shell
系统调用接口
标准库函数
标准函数：打开、关闭、读、写、创建、撤销
操作系统
系统调用：进程管理、有储管理、文件管理、设备管理
图9-7UNIX/Linux系统程序、库函数、系统调用的分层关系
9.5
UNIX系统调用
在上一节中，我们对系统调用做了一般性的描述。为使读者能对系统调用有较具体的
297

--- Page 309 ---
计算机操作系统
了解，在本节中将对UNIX系统中的系统调用作扼要的阐述。在UNIX系统V最早的版本
中，提供了56条系统调用；后来，随着版本的不断翻新，所提供的系统调用也不断增加，
其数量已增至数百条，其中较常用的系统调用大约有30多条。根据其功能的不同，我们同
样可将它们分为：进程控制、文件操纵、进程间通信和信息维护等几大类。
9.5.1进程控制
一←
该类系统调用包括创建进程的系统调用fork、终止进程的系统调用exit、等待子进程
结束的系统调用wait等十多条。
1.进程的创建和终止
（1）创建进程（fork)。一个进程可以利用fork系统调用来创建一个新进程。新进程作为
调用者的子进程，它继承了其父进程的环境、已打开的所有文件、根目录和当前目录等，
即它继承了父进程几乎所有的属性，并具有与其父进程基本上相同的进程映像。
(2）终止进程（exit)。一个进程可以利用exit实现自我终止。通常，在父进程创建子进
程时，便在子进程的末尾安排一条exit系统调用。这样，子进程在完成规定的任务后，便
可进行自我终止。子进程终止后，留下一条记账信息status，其中包含了子进程运行时记录
下来的各种统计信息。
2.改变进程映像和等待
一个可执行的文件覆盖，此即改变调用者进程的进程映像。该系统调用是UNIX系统中最
复杂的系统调用之一。
(2）等待子进程结束（wait)。wait用于将调用者进程自身挂起，直至它的某一子进程终
止为止。这样，父进程可以利用wait使自身的执行与子进程的终止同步。
3.其它进程调用
（1）获得进程ID。UNIX系统提供了一组用于获得进程标识符的系统调用，比如，可
利用getp-id系统调用来获得调用进程的标识符，利用getpgrp系统调用来获得调用进程的
进程组ID，以及利用getppid系统调用来获得调用进程的父进程ID等。
于获得真正的用户ID，geteuid用于获得有效用户ID，getgid用于获得真正用户组ID等。
(3）进程暂停(pause)。可用此系统调用将调用进程挂起，直至它收到一个信号为止。
9.5.2文件操纵
用于对文件进行操纵的系统调用是数量最多的一类系统调用，其中包括创建文件、打
开文件、关闭文件、读文件及写文件等二十多条。
1.文件的创建和删除
(1）创建文件(creat)。系统调用creat 的功能是根据用户提供的文件名和许可权方式，
来创建一个新文件或重写一个已存文件。如果系统中不存在指名文件，核心便以给定的文
件名和许可权方式，来创建一个新文件；如果系统中已有同名文件，核心便释放其已有的数
据块。创建后的文件随即被打开，并返回其文件描述符fd。若creat执行失败，便返回“-1”。
298

--- Page 310 ---
第九章操作系统接口
(2）删除文件。在UNIX系统中没有专门的删除文件的系统调用，故无人可对文件进
行删除，只有当文件的确已无人需要时才删除它。在建立与文件的连接和去连接系统调用
中作进一步的说明。
2.文件的打开和关闭
(1）打开文件(open)。设置系统调用open 的目的是为了方便用户及简化系统的处理。
open的功能是把有关的文件属性从磁盘拷贝到内存中，以及在用户和指名文件之间建立一
都只须使用fd而非路径名。
即断开用户程序与该文件之间已经建立的快捷通路。在UNIX系统中，由于允许一个文件
被多个进程所共享，故只有在无其他任何进程再需要对它进行访问时，或者说，在对其索
引结点中的访问计数i-count执行减1操作后其值为0，表示已无进程再访问该文件时，才
能真正关闭该文件。
3.文件的读和写
读和写文件的系统调用是read和write。仅当用户利用open打开指定文件后，方可调
用read或write对文件执行读或写操作。两个系统调用都要求用户提供三个输入参数：①文
件描述符fd。②buf缓冲区首址。对读而言，这是用户所要求的信息传送的目标地址；对
写而言，则是信息传送的源地址。③用户要求传送的字节数nbyte。
系统调用read的功能是试图从fd所指示的文件中去读入nbyte个字节的数据，并将它
们送至由指针buf所指示的缓冲区中；系统调用write的功能是试图把nbyte个字节数据从
指针buf所指示的缓冲区中写到由fd所指向的文件中。
4.建立与文件的连接和去连接
(1）连接(link)。为了实现文件共享，必须记住所有共享该文件的用户数目。为此，在
该文件的索引结点中设置了一个连接计数ilink。每当有一用户要共享某文件时，须利用系
统调用link来建立该用户（进程）与此文件之间的连接，并对i.link做加1操作。
（2）去连接（unlink)。当用户不再使用此文件时，应利用系统调用unlink去断开此连接，
亦即做i.link的减1操作。当i.link减1后结果为0时，表示已无用户需要此文件，此时才
能将该文件从文件系统中删除。故在UNIX系统中并无一条删除文件的系统调用。
9.5.3进程通信和信息保护
1.进程通信
为了实现进程间的通信，在UNIX系统中提供了一个用于进程间通信的软件包，简称
IPC。它由消息机制、共享存储器机制和信号量机制三部分组成。在每一种通信机制中，都
提供了相应的系统调用供用户程序进行进程间的同步与通信用。
(1）消息机制。用户(进程)在利用消息机制进行通信时，必须先利用msgget系统调用
来建立一个消息队列。若成功，便返回消息队列描述符msgid，以后用户便可利用msgid
去访问该消息队列。用户(进程)可利用发送消息的系统调用msgsend向用户指定的消息队
列发送消息；利用msgrcv系统调用从指定的消息队列中接收指定类型的消息。
299

--- Page 311 ---
计算机操作系统
(2）共享存储器机制。当用户(进程)要利用共享存储器机制进行通信时，必须先利用
shmget系统调用来建立一个共享存储区，若成功，便返回该共享存储区描述符shmid。以
后，用户便可利用shmid去访问该共享存储区。进程在建立了共享存储区之后，还必须再
利用shmat将该共享存储区连接到本进程的虚地址空间上。以后，在进程之间便可利用该
共享存储区进行通信。当进程不再需要该共享存储区时，可利用shmdt系统调用来拆除进
程与共享存储区间的连接。
2.信息维护
在UNIX系统中，设置了许多条用于系统维护的系统调用，下面介绍常用的几条。
（1）设置和获得时间。超级用户可利用设置时间的系统调用（stime）来设置系统的日期和
时间：如果调用进程并非超级用户，则stime失败；一般用户可利用获得时间的系统调用
time来获得当前的日期和时间。
(2）获得进程和子进程时间（times)。利用该系统调用可获得进程及其子进程所使用的
CPU时间，其中包括调用进程在用户空间执行指令所花费的时间，系统为调用进程所花费
的CPU时间，子进程在用户空间所用的CPU时间，系统为各子进程所花费的CPU时间等，
并可将这些时间填写到一个指定的缓冲区。
（3）设置文件访问和修改时间（utime)。该系统调用用于设置指名文件被访问和修改的
时间。如果该系统调用的参数times为NULL，则文件主和对该文件具有写权限的用户可
将对该文件的访问和修改时间设置为当前时间；如果times不为NULL，则把times解释
为指向utimbuf结构的指针，此时，文件主和超级用户能将访问时间和修改时间置入utim
buf结构中。
（4）获得当前UNIX系统的名称（uname)。利用该系统调用可将有关UNIX系统的信息
存储在utsname结构中。这些信息包括UNIX系统名称的字符串、系统在网络中的名称、硬
件的标准名称等。
/9.6系统调用的实现
系统调用的实现与一般过程调用的实现相比，两者间有很大差异。对于系统调用，控
制是由原来的用户态转换为系统态，这是借助于陷入机制来完成的，在该机制中包括陷入
硬件机构及陷入处理程序两部分。当应用程序使用OS的系统调用时，产生一条相应的指
令，CPU在执行这条指令时发生中断，并将有关信号送给中断和陷入硬件机构，该机构收
到信号后，启动相关的陷入处理程序进行处理，实现该系统调用所需要的功能。
9.6.1系统调用的实现方法
一一一←
1.系统调用号和参数的设置
号。在系统调用命令（陷入指令）中把相应的系统调用号传递给中断和陷入机制的方法有很
300