

--- Page 274 ---
第八章磁盘存储器的管理
而在S.free(O)中则存放“0”，作为空闲盘块链的结束标志。（注：最后一组的盘块数应为
99，不应是100，因为这是指可供使用的空闲盘块。其编号应为(1～99)，0号中放空闲盘
块链的结尾标志。）
2.空闲盘块的分配与回收
当系统要为用户分配文件所需的盘块时，须调用盘块分配过程来完成。该过程首先检
查空闲盘块号栈是否上锁，如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分
配给用户，然后将栈顶指针下移一格。若该盘块号已是栈底，即S.free（O)，这是当前栈中
最后一个可分配的盘块号。由于在该盘块号所对应的盘块中记有下一组可用的盘块号，因
此，须调用磁盘读过程将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内
容，并把原栈底对应的盘块分配出去（其中的有用数据已读入栈中）。然后，再分配一相应
的缓冲区（作为该盘块的缓冲区）。最后，把栈中的空闲盘块数减1并返回。
在系统回收空闲盘块时，须调用盘块回收过程进行回收。它是将回收盘块的盘块号记
入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。当栈中空闲盘块号数目已达100时，
表示栈已满，便将现有栈中的100个盘块号记入新回收的盘块中，再将其盘块号作为新栈底。
/8.3提高磁盘1/0速度的途径
文件系统的性能可表现在多个方面，其中至关重要的一个方面是对文件的访问速度。
为了提高对文件的访问速度，可从三方面着手：
（1）改进文件的目录结构以及检索目录的方法来减少对目录的查找时间；
(2）选取好的文件存储结构，以提高对文件的访问速度；
（3）提高磁盘的I/O速度，能将文件中的数据快速地从磁盘传送到内存中，或者相反。
速度作一简单介绍。
目前，磁盘的IO速度远低于对内存的访问速度，通常要低上4～6个数量级。因此，
磁盘的IO已成为计算机系统的瓶颈。于是，人们便干方百计地去提高磁盘I/O的速度，
其中最主要的技术便是采用磁盘高速缓存。
8.3.1磁盘高速缓存（DiskCache)
一一一一一一
在前面介绍的高速缓存，是指在内存和CPU之间所增设的一个小容量高速存储器。而
在这里所要介绍的磁盘高速缓存，是指在内存中为磁盘盘块设置的一个缓冲区，在缓冲区中
保存了某些盘块的副本。当出现一个访问磁盘的请求时，由核心先去查看磁盘高速缓冲器，
看所请求的盘块内容是否已在磁盘高速缓存中，如果在，便可从磁盘高速缓存中去获取，这
样就省去了启动磁盘操作，而且可使本次访问速度提高几个数量级；如果不在，才需要启动
磁盘将所需要的盘块内容读入，并把所需盘块内容送给磁盘高速缓存，以便以后又需要访问
该盘块的数据时，便可直接从高速缓存中提取。在设计磁盘高速缓存时需要考虑的问题有：
(1）如何将磁盘高速缓存中的数据传送给请求进程；
(2）采用什么样的置换策略；
263

--- Page 275 ---
计算机操作系统
(3）已修改的盘块数据在何时被写回磁盘。
下面对它们做简单介绍。
1.数据交付(DataDelivery)方式
如果IVO请求所需要的数据能从磁盘高速缓存中获取，此时就需要将磁盘高速缓存中
的数据传送给请求进程。所谓的数据交付就是指将磁盘高速缓存中的数据传送给请求者进
程。系统可以采取两种方式将数据交付给请求进程：
（1）数据交付，这是直接将高速缓存中的数据传送到请求者进程的内存工作区中；
(2）指针交付，只将指向高速缓存中某区域的指针交付给请求者进程。后一种方式由于
所传送的数据量少，因而节省了数据从磁盘高速缓存存储空间到进程的内存工作区的时间。
2.置换算法
如同请求调页(段)一样，在将磁盘中的盘块数据读入高速缓存时，同样会出现因高速
缓存中已装满盘块数据，而需要将其中某些盘块的数据先换出的问题。相应地，也存在着
采用哪种置换算法的问题。较常用的算法仍然是最近最久未使用算法LRU、最近未使用算
法NRU及最少使用算法LFU等。由于请求调页中的联想存储器与高速缓存（磁盘IVO中）的
工作情况不同，因而使得在置换算法中所应考虑的问题也有所差异。因此，现在不少系统在
设计其高速缓存的置换算法时，除了考虑到最近最久未使用这一原则外，还考虑了以下几点：
（1）访问频率。通常，每执行一条指令时，便可能访问一次联想存储器，亦即联想存
储器的访问频率基本上与指令执行的频率相当。而对磁盘高速缓存的访问频率，则与磁盘
I/O的频率相当。因此，对联想存储器的访问频率远远高于对磁盘高速缓存的访问频率。
（2）可预见性。在磁盘高速缓存中的各盘块数据，有哪些数据可能在较长时间内不会
再被访问，又有哪些数据可能很快就再被访问，会有相当一部分是可预知的。例如，对二
次地址及目录块等，在它被访问后，可能会很久都不再被访问。又如，正在写入数据的未
满盘块，可能会很快又被访问。
（3）数据的一致性。由于磁盘高速缓存在内存中，而内存是一种易失性的存储器，一
旦系统发生故障，存放在缓存中的数据将会丢失；而其中有些盘块（如索引结点盘块）中的
数据已被修改，但尚未拷回磁盘。因此，当系统发生故障后，可能造成数据的不一致性。
基于上述考虑，在有的系统中便将磁盘高速缓存中的所有盘块数据拉成一条LRU链。
对于那些会严重影响到数据一致性的盘块数据和很久都可能不再使用的盘块数据，都放在
LRU链的头部，使它们能被优先写回磁盘，以减少发生数据不一致性的概率，或者可以尽
早地腾出高速缓存的空间。对于那些可能在不久之后便要再次使用的盘块数据，应挂在LRU
链的尾部，以便在以后需要时，只要该块中数据尚未被写回磁盘，便可直接从LRU链中找
到它们。
3.周期性地写回磁盘
还有一种情况值得注意，那就是根据LRU算法，那些经常要被访问的盘块数据可能会
一直保留在高速缓存中，长期不会被写回磁盘。这是因为链中任一元素在被访问之后，又
被挂到链尾而不被写回磁盘，只有一直未被访问的元素才有可能移到链首，而被写回磁盘。
为了解决这一问题，在UNIX系统中专门增设了一个修改(update)程序，使之在后台运行，
该程序周期性地调用一个系统调用SYNC。其主要功能是强制性地将所有在高速缓存中已
264

--- Page 276 ---
第八章磁盘存储器的管理
修改的盘块数据写回磁盘。一般是把两次调用SYNC的时间间隔定为30s。这样，因系统
故障所造成的工作损失不会超过30s的工作量。
8.3.2提高磁盘1/0速度的其它方法
能有效地提高磁盘I/O速度的方法还有许多，如提前读、延迟写等，现介绍如下：
1.提前读
如果是采用顺序访问方式对文件进行访问，便可以预知下一次要读的盘块。此时可采
取预先读方式，即在读当前块的同时，还要求将下一个盘块（提前读的块）中的数据也读入
缓冲区。这样，当下一次要读该盘块中的数据时，由于该数据已被提前读入缓冲区，因而
此时便可直接从缓冲区中取得下一盘块的数据，而不须再去启动磁盘I/O，从而大大减少了
读数据的时间，有效地提高了磁盘IO的速度。“提前读”功能已被广泛采用。
2.延迟写
延迟写是指缓冲区A中的数据本应立即写回磁盘，但考虑到该缓冲区中的数据可能会
在不久之后再被本进程或其它进程访问（共享资源），因而并不立即将该缓冲区A中的数据
写入磁盘，而是将它挂在空闲缓冲区队列的末尾。随着空闲缓冲区的使用，缓冲区也缓缓
往前移动，直至移到空闲缓冲队列之首。当再有进程申请到该缓冲区时，才将该缓冲区中
的数据写入磁盘，而把该缓冲区作为空闲缓冲区分配出去。只要该缓冲区A仍在队列中时，
任何访问该数据的进程，都可直接读出其中的数据而不必访问磁盘。这样，又可进一步减
少磁盘的IVO时间。同样，延迟写功能也已被广泛采用。
3.优化物理块的分布
在采用链接组织和索引组织方式时，可以将一个文件分散在磁盘的任意位置，但如果
安排得过于分散，会增加磁头的移动距离。例如，将文件的第一个盘块安排在最里的一条
磁道上，而把第二个盘块安排在最外的一条磁道上，这样，在读完第一个盘块后转去读第
二个盘块时，磁头要从最里的磁道移到最外的磁道上。如果我们将这两个数据块安排在属
于同一条磁道的两个盘块上，显然会由于消除了磁头在磁道间的移动，而大大提高对这两
个盘块的访问速度。
对文件盘块位置的优化，应在为文件分配盘块时进行。如果系统中的空白存储空间是
采用位示图方式表示时，要将同属于一个文件的盘块安排在同一条磁道上或相邻的磁道上
是十分容易的事。这时，只要从位示图中找到一片相邻接的多个空闲盘块即可。但当系统
采用线性表（链）法来组织空闲存储空间时，要为一文件分配多个相邻接的盘块就要困难一
些。此时，我们可以将在同一条磁道上的若干个盘块组成一簇，例如，一簇包括4个盘块，
在分配存储空间时，以簇为单位进行分配。这样就可以保证在访问这几个盘块时，不必移
动磁头或者仅移动一条磁道的距离，从而减少了磁头的平均移动距离。
4.虚拟盘
由于访问内存的速度远高于访问磁盘的速度，于是有人试图利用内存空间去仿真磁盘，
形成所谓虚拟盘，又称为RAM盘。该盘的设备驱动程序也可以接受所有标准的磁盘操作，
但这些操作的执行不是在磁盘上而是在内存中。这对用户都是透明的。换言之，用户不会
发现这与真正的磁盘操作有什么不同，而仅仅是略微快些而已。虚拟盘的主要问题是：它
265

--- Page 277 ---
计算机操作系统
是易失性存储器，故一旦系统或电源发生故障，或系统再启动时，原来保存在虚拟盘中的
数据将会丢失。因此，虚拟盘通常用于存放临时文件，如编译程序所产生的目标程序等。
虚拟盘与磁盘高速缓存的主要区别在于：虚拟盘中的内容完全由用户控制，而磁盘高速缓
存中的内容则是由OS控制的。例如，RAM盘在开始时是空的，仅当用户（程序）在RAM
盘中创建了文件后，RAM盘中才有内容。
8.3.3廉价磁盘余阵列（RAID）
当今存在着一种非常有用的设计思想，如果使用一个组件对性能的改进受到了很大的
限制，那么可通过使用多个相同的组件来获得性能的大幅度提高，这种情况在计算机领域中
已屡见不鲜。正是在这种设计思想推动下，由单处理机系统演变为多处理机系统；在芯片上
由单核演变为多核。同样也用该思想来指导磁盘存储器的设计，人们于1987年开发出由多
个小磁盘组成一个大容量的廉价磁盘余阵列(RedundantArrayofInexpensiveDisk，RAID)。
该系统是利用一台磁盘阵列控制器来统一管理和控制一组(几台到几十台)磁盘驱动器，
组成一个大型磁盘系统。RAID不仅是大幅度地增加了磁盘的容量，而且也极大地提高了磁
1.并行交叉存取
这是把在大、中型机中，用于提高访问内存速度的并行交叉存取技术应用到磁盘存储
系统中，以提高对磁盘的IVO速度。在该系统中，有多台磁盘驱动器，系统将每一盘块中
的数据分为若干个子盘块数据，再把每一个子盘块的数据分别存储到各个不同磁盘中的相
同位置上。以后当要将一个盘块的数据传送到内存时，采取并行传输方式，将各个盘块中
的子盘块数据同时向内存中传输，从而使传输时间大大减少。例如，在存放一个文件时，
磁盘上；·；将第N个数据子块放在第N个磁盘上。以后在读取数据时，采取并行读取
方式，即同时从第1～N个数据子块中读出数据，这样便把磁盘I/O的速度提高了N-1倍。
图8-12示出了磁盘并行交义存取方式。
Vm
图8-12磁盘并行交叉存取方式
2.RAID的分级
RAID在刚被推出时，是分成6级的，后来文增加了RAID6级和RAID7级。
（1）RAIDO级。本级仅提供了并行交叉存取。RAIDO级的主要优点是，它能够实现
高效的传输，并能实现高速的IV/O请求。主要缺点是无冗余校验功能，致使磁盘系统的可
靠性并不是很高。只要阵列中有一个磁盘损坏，便会造成不可弥补的数据去失，故导致该
级较少使用。
(2）RAID1级。它具有磁盘镜像功能，例如，当磁盘阵列中具有8个盘时，可利用其
266

--- Page 278 ---
第八章磁盘存储器的管理
中4个作为数据盘，另外4个作为镜像盘，在每次访问磁盘时，可利用并行读、写特性，
将数据分块同时写入主盘和镜像盘。RAID1级的主要优点是可靠性好，且从故障中恢复很
简单。其缺点是磁盘容量的利用率只有50%，它的优点是以牺牲磁盘容量为代价的。
（3）RAID3级。这是具有并行传输功能的磁盘阵列。它只利用一台奇偶校验盘来完成
数据的校验功能。例如，当阵列中只有7个盘时，可利用6个盘作数据盘，一个盘作校验
盘。磁盘的利用率为6/7。
（4）RAID5级。这是一种具有独立传送功能的磁盘阵列。每个驱动器都各有自己独立
的数据通路，独立地进行读/写，且无专门的校验盘。用来进行纠错的校验信息是以螺旋
(Spiral)方式散布在所有数据盘上。
（5）RAID6级和RAID7级。这是强化了的RAID。在RAID6级的阵列中，设置了一
个专用的、可快速访问的异步校验盘。该盘具有独立的数据访问通路，具有比RAID3级
及RAID5级更好的性能，但其性能改进得很有限，且价格昂贵。RAID7级是对RAID6
级的改进，在该阵列中的所有磁盘都具有较高的传输速率和优异的性能，是目前最高档次
的磁盘阵列，但其价格也较高。
3.RAID的优点
RAID具有下述一系列明显的优点：
(1）可靠性高，除了RAIDO级外，其余各级都采用了容错技术。当阵列中某一磁盘损
坏时，并不会造成数据的丢失。此时可根据其它未损坏磁盘中的信息来恢复已损坏的盘中
的信息。其可靠性比单台磁盘机高出一个数量级。
（2）磁盘I/O速度高，由于采取了并行交叉存取方式，可使磁盘I/O速度提高N-1倍。
(3）性能/价格比高，RAID的体积与具有相同容量和速度的大型磁盘系统相比，只是
后者的1/3，价格也只是后者的1/3，且可靠性高。换言之，它仅以牺牲1/N的容量为代价，
换取了高可靠性。
/8.4提高磁盘可靠性的技术
在前一章中已经介绍了影响文件安全性的主要因素有人为因素、系统因素和自然因素
三类。同时也说明了为确保文件系统的安全性应采取的三方面的措施。采用存取控制机制
技术来防止人为因素造成文件的不安全性，已在7.5节中进行了较详细的阐述，在本小节
主要介绍通过磁盘容错技术来防止由系统因素造成的文件的不安全性和建立“后备系统”
来防止由自然因素所造成的不安全性。
容错技术是通过在系统中设置余部件的办法，来提高系统可靠性的一种技术。磁盘
容错技术则是通过增加余的磁盘驱动器、磁盘控制器等方法来提高磁盘系统可靠性的一
种技术。即当磁盘系统的某部分出现缺陷或故障时，磁盘仍能正常工作，且不致造成数据
的丢失或错误。目前广泛采用磁盘容错技术来改善磁盘系统的可靠性。
磁盘容错技术往往也被人们称为系统容错技术SFT。可把它分成三个级别：第一级是
低级磁盘容错技术；第二级是中级磁盘容错技术；第三级是系统容错技术，它基于集群技
术实现容错。
267